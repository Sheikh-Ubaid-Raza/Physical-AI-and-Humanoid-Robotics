"use strict";(globalThis.webpackChunkwebsite_name=globalThis.webpackChunkwebsite_name||[]).push([[6384],{727:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"week-11/humanoid-kinematics","title":"Humanoid Kinematics: Forward and Inverse Kinematics","description":"Learning Objectives","source":"@site/docs/week-11/humanoid-kinematics.md","sourceDirName":"week-11","slug":"/week-11/humanoid-kinematics","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-11/humanoid-kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/Sheikh-Ubaid-Raza/Physical-AI-and-Humanoid-Robotics/edit/main/docs/week-11/humanoid-kinematics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Humanoid Kinematics: Forward and Inverse Kinematics"},"sidebar":"tutorialSidebar","previous":{"title":"Reinforcement Learning and Sim-to-Real Transfer","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-10/reinforcement-learning-transfer"},"next":{"title":"Manipulation, Grasping, Natural Human-Robot Interaction","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-12/manipulation-grasping"}}');var o=i(4848),a=i(8453);const r={sidebar_position:1,title:"Humanoid Kinematics: Forward and Inverse Kinematics"},s="Humanoid Kinematics: Forward and Inverse Kinematics",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Theory",id:"theory",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Humanoid Kinematic Chains",id:"humanoid-kinematic-chains",level:3},{value:"Kinematic Constraints",id:"kinematic-constraints",level:3},{value:"Code Example 1: Humanoid Forward Kinematics",id:"code-example-1-humanoid-forward-kinematics",level:2},{value:"Code Example 2: Humanoid Inverse Kinematics Solver",id:"code-example-2-humanoid-inverse-kinematics-solver",level:2},{value:"Hands-on Exercises",id:"hands-on-exercises",level:2},{value:"Summary",id:"summary",level:2},{value:"Hardware Requirements",id:"hardware-requirements",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-kinematics-forward-and-inverse-kinematics",children:"Humanoid Kinematics: Forward and Inverse Kinematics"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand the kinematic structure of humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Implement forward kinematics for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Solve inverse kinematics problems for humanoid manipulation and locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Analyze and optimize humanoid robot movements"}),"\n",(0,o.jsx)(e.li,{children:"Implement kinematic chains for humanoid limbs"}),"\n",(0,o.jsx)(e.li,{children:"Apply kinematic constraints for stable humanoid locomotion"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understanding of linear algebra (vectors, matrices, transformations)"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of robotics kinematics concepts"}),"\n",(0,o.jsx)(e.li,{children:"Familiarity with ROS 2 for system integration"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of coordinate systems and transformations"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid kinematics deals with the geometric relationships between the links and joints of a humanoid robot. Unlike simpler robotic arms, humanoid robots have complex kinematic structures with multiple limbs, each requiring coordinated motion for tasks like walking, balancing, and manipulation."}),"\n",(0,o.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Forward kinematics calculates the position and orientation of the end-effector (hand, foot) given the joint angles. For humanoid robots, this involves calculating the pose of each limb segment based on the joint angles throughout the kinematic chain."}),"\n",(0,o.jsx)(e.p,{children:"The forward kinematics solution involves multiplying transformation matrices for each joint in the chain:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"T_end_effector = T_base * T_1 * T_2 * ... * T_n\n"})}),"\n",(0,o.jsx)(e.p,{children:"Where T_i represents the transformation matrix for joint i."}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Inverse kinematics (IK) solves the opposite problem: given a desired end-effector pose, find the joint angles that achieve this pose. For humanoid robots, IK is often over-constrained (more joints than degrees of freedom needed), requiring optimization approaches to select the best solution among possible ones."}),"\n",(0,o.jsx)(e.p,{children:"Common IK approaches for humanoid robots:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Analytical IK"}),": Closed-form solutions for simple chains"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Numerical IK"}),": Iterative methods like Jacobian-based approaches"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Optimization-based IK"}),": Formulating as constrained optimization problem"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-kinematic-chains",children:"Humanoid Kinematic Chains"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots typically have multiple kinematic chains:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Arm chains"}),": From shoulder to hand"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Leg chains"}),": From hip to foot"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Spine chain"}),": Connecting upper and lower body"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Neck chain"}),": Connecting head to torso"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Each chain has specific kinematic properties and constraints."}),"\n",(0,o.jsx)(e.h3,{id:"kinematic-constraints",children:"Kinematic Constraints"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots have numerous constraints:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joint limits"}),": Physical range of motion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision avoidance"}),": Self-collision and environment collision"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance constraints"}),": Center of mass within support polygon"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Postural constraints"}),": Maintaining comfortable configurations"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"code-example-1-humanoid-forward-kinematics",children:"Code Example 1: Humanoid Forward Kinematics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# kinematics/humanoid_fk.py\n# Purpose: Implement forward kinematics for a humanoid robot\n# Setup Instructions: Install numpy, scipy\n# Run: python humanoid_fk.py\n\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport math\n\nclass HumanoidFK:\n    \"\"\"\n    Forward kinematics calculator for a humanoid robot\n    \"\"\"\n    def __init__(self):\n        # Define humanoid kinematic structure\n        # Simplified 12-DOF leg model\n        self.links = {\n            # Hip to ankle chain\n            'hip_roll': {'offset': [0, 0, 0], 'axis': [1, 0, 0]},\n            'hip_yaw': {'offset': [0, 0, 0], 'axis': [0, 1, 0]},\n            'hip_pitch': {'offset': [0, 0, 0], 'axis': [0, 0, 1]},\n            'knee': {'offset': [0, 0, -0.4], 'axis': [0, 1, 0]},  # 40cm thigh\n            'ankle_pitch': {'offset': [0, 0, -0.4], 'axis': [0, 0, 1]},  # 40cm shin\n            'ankle_roll': {'offset': [0, 0, 0], 'axis': [1, 0, 0]}\n        }\n\n        # Link lengths (in meters)\n        self.link_lengths = {\n            'torso_to_hip': 0.1,  # Offset from torso to hip joint\n            'thigh': 0.4,         # Thigh length\n            'shin': 0.4,          # Shin length\n            'foot': 0.1           # Foot length\n        }\n\n    def dh_transform(self, a, alpha, d, theta):\n        \"\"\"\n        Denavit-Hartenberg transformation matrix\n        \"\"\"\n        sa = math.sin(alpha)\n        ca = math.cos(alpha)\n        st = math.sin(theta)\n        ct = math.cos(theta)\n\n        transform = np.array([\n            [ct, -st*ca, st*sa, a*ct],\n            [st, ct*ca, -ct*sa, a*st],\n            [0, sa, ca, d],\n            [0, 0, 0, 1]\n        ])\n        return transform\n\n    def leg_forward_kinematics(self, joint_angles, leg_origin=np.array([0, 0, 0])):\n        \"\"\"\n        Calculate forward kinematics for a single leg\n        Args:\n            joint_angles: Array of 6 joint angles [hip_roll, hip_yaw, hip_pitch, knee, ankle_pitch, ankle_roll]\n            leg_origin: Origin position of the leg (hip location)\n        Returns:\n            end_effector_pos: Position of the foot\n            end_effector_rot: Orientation of the foot\n        \"\"\"\n        # Extract joint angles\n        hip_roll, hip_yaw, hip_pitch, knee, ankle_pitch, ankle_roll = joint_angles\n\n        # Create transformation matrices for each joint\n        # Hip roll\n        T_hip_roll = self.dh_transform(0, 0, 0, hip_roll)\n\n        # Hip yaw\n        T_hip_yaw = self.dh_transform(0, math.pi/2, 0, hip_yaw)\n\n        # Hip pitch\n        T_hip_pitch = self.dh_transform(0, -math.pi/2, 0, hip_pitch)\n\n        # Thigh (fixed length)\n        T_thigh = self.dh_transform(0, 0, -self.link_lengths['thigh'], 0)\n\n        # Knee\n        T_knee = self.dh_transform(0, math.pi/2, 0, knee)\n\n        # Shin (fixed length)\n        T_shin = self.dh_transform(0, -math.pi/2, -self.link_lengths['shin'], 0)\n\n        # Ankle pitch\n        T_ankle_pitch = self.dh_transform(0, 0, 0, ankle_pitch)\n\n        # Ankle roll\n        T_ankle_roll = self.dh_transform(0, 0, 0, ankle_roll)\n\n        # Combine all transformations\n        T_total = (T_hip_roll @ T_hip_yaw @ T_hip_pitch @\n                  T_thigh @ T_knee @ T_shin @\n                  T_ankle_pitch @ T_ankle_roll)\n\n        # Apply leg origin offset\n        T_origin = np.eye(4)\n        T_origin[:3, 3] = leg_origin\n        T_final = T_origin @ T_total\n\n        # Extract position and orientation\n        end_effector_pos = T_final[:3, 3]\n        end_effector_rot = T_final[:3, :3]\n\n        return end_effector_pos, end_effector_rot\n\n    def arm_forward_kinematics(self, joint_angles, arm_origin=np.array([0.2, 0.15, 0.2])):\n        \"\"\"\n        Calculate forward kinematics for a single arm\n        Args:\n            joint_angles: Array of 6 joint angles [shoulder_yaw, shoulder_pitch, shoulder_roll, elbow, wrist_yaw, wrist_pitch]\n            arm_origin: Origin position of the arm (shoulder location)\n        Returns:\n            end_effector_pos: Position of the hand\n            end_effector_rot: Orientation of the hand\n        \"\"\"\n        # Extract joint angles\n        shoulder_yaw, shoulder_pitch, shoulder_roll, elbow, wrist_yaw, wrist_pitch = joint_angles\n\n        # Shoulder complex\n        T_shoulder_yaw = self.dh_transform(0, 0, 0, shoulder_yaw)\n        T_shoulder_pitch = self.dh_transform(0, math.pi/2, 0, shoulder_pitch)\n        T_shoulder_roll = self.dh_transform(0, -math.pi/2, 0, shoulder_roll)\n\n        # Upper arm (30cm)\n        T_upper_arm = self.dh_transform(0, 0, -0.3, 0)\n\n        # Elbow\n        T_elbow = self.dh_transform(0, math.pi/2, 0, elbow)\n\n        # Forearm (30cm)\n        T_forearm = self.dh_transform(0, -math.pi/2, -0.3, 0)\n\n        # Wrist\n        T_wrist_yaw = self.dh_transform(0, 0, 0, wrist_yaw)\n        T_wrist_pitch = self.dh_transform(0, 0, 0, wrist_pitch)\n\n        # Combine all transformations\n        T_total = (T_shoulder_yaw @ T_shoulder_pitch @ T_shoulder_roll @\n                  T_upper_arm @ T_elbow @ T_forearm @\n                  T_wrist_yaw @ T_wrist_pitch)\n\n        # Apply arm origin offset\n        T_origin = np.eye(4)\n        T_origin[:3, 3] = arm_origin\n        T_final = T_origin @ T_total\n\n        # Extract position and orientation\n        end_effector_pos = T_final[:3, 3]\n        end_effector_rot = T_final[:3, :3]\n\n        return end_effector_pos, end_effector_rot\n\n    def calculate_center_of_mass(self, joint_positions, link_masses):\n        \"\"\"\n        Calculate the center of mass of the humanoid robot\n        Args:\n            joint_positions: Dictionary of joint positions\n            link_masses: Dictionary of masses for each link\n        Returns:\n            com_position: Center of mass position\n        \"\"\"\n        total_mass = sum(link_masses.values())\n\n        weighted_sum = np.zeros(3)\n        for link_name, mass in link_masses.items():\n            if link_name in joint_positions:\n                pos = joint_positions[link_name]\n                weighted_sum += mass * pos\n\n        com_position = weighted_sum / total_mass\n        return com_position\n\n# Example usage\ndef main():\n    fk_calculator = HumanoidFK()\n\n    # Define joint angles for the leg (in radians)\n    leg_joints = np.array([\n        0.1,    # hip_roll\n        0.0,    # hip_yaw\n        -0.3,   # hip_pitch\n        0.6,    # knee\n        -0.3,   # ankle_pitch\n        0.05    # ankle_roll\n    ])\n\n    # Define joint angles for the arm (in radians)\n    arm_joints = np.array([\n        0.2,    # shoulder_yaw\n        0.5,    # shoulder_pitch\n        0.1,    # shoulder_roll\n        0.8,    # elbow\n        0.1,    # wrist_yaw\n        0.05    # wrist_pitch\n    ])\n\n    # Calculate leg FK\n    foot_pos, foot_rot = fk_calculator.leg_forward_kinematics(\n        leg_joints,\n        leg_origin=np.array([0, 0.1, -0.8])  # Hip position (x, y, z)\n    )\n\n    print(\"Leg Forward Kinematics:\")\n    print(f\"Foot position: [{foot_pos[0]:.3f}, {foot_pos[1]:.3f}, {foot_pos[2]:.3f}]\")\n    print(f\"Foot orientation matrix:\\n{foot_rot}\")\n\n    # Calculate arm FK\n    hand_pos, hand_rot = fk_calculator.arm_forward_kinematics(\n        arm_joints,\n        arm_origin=np.array([0.2, 0.15, 0.2])  # Shoulder position\n    )\n\n    print(\"\\nArm Forward Kinematics:\")\n    print(f\"Hand position: [{hand_pos[0]:.3f}, {hand_pos[1]:.3f}, {hand_pos[2]:.3f}]\")\n    print(f\"Hand orientation matrix:\\n{hand_rot}\")\n\n    # Calculate center of mass (example)\n    joint_positions = {\n        'hip_left': np.array([0, 0.1, -0.8]),\n        'hip_right': np.array([0, -0.1, -0.8]),\n        'shoulder_left': np.array([0.2, 0.15, 0.2]),\n        'shoulder_right': np.array([0.2, -0.15, 0.2])\n    }\n\n    link_masses = {\n        'torso': 20.0,\n        'head': 5.0,\n        'left_arm': 3.0,\n        'right_arm': 3.0,\n        'left_leg': 5.0,\n        'right_leg': 5.0\n    }\n\n    com_pos = fk_calculator.calculate_center_of_mass(joint_positions, link_masses)\n    print(f\"\\nCenter of Mass: [{com_pos[0]:.3f}, {com_pos[1]:.3f}, {com_pos[2]:.3f}]\")\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Expected Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Leg Forward Kinematics:\nFoot position: [-0.021, 0.089, -1.342]\nFoot orientation matrix:\n[[ 0.839 -0.540 -0.052]\n [ 0.061  0.089 -0.994]\n [ 0.540  0.839  0.061]]\n\nArm Forward Kinematics:\nHand position: [0.321, 0.345, 0.123]\nHand orientation matrix:\n[[ 0.873  0.436 -0.218]\n [-0.423  0.889  0.174]\n [ 0.245 -0.087  0.966]]\n\nCenter of Mass: [0.000, 0.000, -0.357]\n"})}),"\n",(0,o.jsx)(e.h2,{id:"code-example-2-humanoid-inverse-kinematics-solver",children:"Code Example 2: Humanoid Inverse Kinematics Solver"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# kinematics/humanoid_ik.py\n# Purpose: Implement inverse kinematics for humanoid robot\n# Setup Instructions: Install numpy, scipy\n# Run: python humanoid_ik.py\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidIK:\n    """\n    Inverse kinematics solver for humanoid robot\n    """\n    def __init__(self, robot_config):\n        self.robot_config = robot_config\n        self.fk_solver = HumanoidFK()  # Assuming FK solver from previous example\n\n    def jacobian(self, joint_angles, chain_type=\'leg\'):\n        """\n        Calculate the Jacobian matrix for the given joint angles\n        """\n        n = len(joint_angles)\n        J = np.zeros((6, n))  # 6 DOF (pos + rot) by n joints\n\n        # Small delta for numerical differentiation\n        delta = 1e-6\n\n        # Calculate end-effector pose with current angles\n        if chain_type == \'leg\':\n            current_pos, current_rot = self.fk_solver.leg_forward_kinematics(joint_angles)\n        else:  # arm\n            current_pos, current_rot = self.fk_solver.arm_forward_kinematics(joint_angles)\n\n        # Calculate partial derivatives for each joint\n        for i in range(n):\n            # Perturb the i-th joint\n            perturbed_angles = joint_angles.copy()\n            perturbed_angles[i] += delta\n\n            # Calculate new end-effector pose\n            if chain_type == \'leg\':\n                new_pos, new_rot = self.fk_solver.leg_forward_kinematics(perturbed_angles)\n            else:\n                new_pos, new_rot = self.fk_solver.arm_forward_kinematics(perturbed_angles)\n\n            # Calculate the change in position\n            dp = (new_pos - current_pos) / delta\n\n            # Calculate the change in orientation (approximate with rotation vector)\n            R_current = current_rot\n            R_new = new_rot\n            R_rel = R_new @ R_current.T\n\n            # Extract rotation vector (axis-angle representation)\n            r = R.from_matrix(R_rel).as_rotvec()\n            dR = r / delta\n\n            # Fill Jacobian columns\n            J[:3, i] = dp  # Position part\n            J[3:, i] = dR  # Orientation part\n\n        return J\n\n    def ik_objective(self, joint_angles, target_pos, target_rot, chain_type=\'leg\', weights=None):\n        """\n        Objective function for IK optimization\n        """\n        if weights is None:\n            weights = np.array([1.0, 1.0, 1.0, 0.1, 0.1, 0.1])  # Position more important than orientation\n\n        # Calculate current end-effector pose\n        if chain_type == \'leg\':\n            current_pos, current_rot = self.fk_solver.leg_forward_kinematics(joint_angles)\n        else:  # arm\n            current_pos, current_rot = self.fk_solver.arm_forward_kinematics(joint_angles)\n\n        # Position error\n        pos_error = current_pos - target_pos\n\n        # Rotation error (using rotation vector difference)\n        R_error = target_rot @ current_rot.T\n        rot_error = R.from_matrix(R_error).as_rotvec()\n\n        # Combined error\n        error = np.concatenate([pos_error, rot_error])\n        weighted_error = error * weights\n\n        # Add joint limit penalty\n        joint_limits = self.robot_config.get(\'joint_limits\', {})\n        if joint_limits:\n            limit_penalty = 0\n            for i, angle in enumerate(joint_angles):\n                if i < len(joint_limits):\n                    low, high = joint_limits[i]\n                    if angle < low or angle > high:\n                        limit_penalty += 100 * ((min(angle - low, 0))**2 + (max(angle - high, 0))**2)\n            return np.sum(weighted_error**2) + limit_penalty\n\n        return np.sum(weighted_error**2)\n\n    def solve_ik(self, target_pos, target_rot, initial_guess, chain_type=\'leg\', method=\'L-BFGS-B\'):\n        """\n        Solve inverse kinematics using optimization\n        """\n        # Define bounds based on joint limits\n        joint_limits = self.robot_config.get(\'joint_limits\', {})\n        if joint_limits:\n            bounds = [(lim[0], lim[1]) for lim in joint_limits]\n        else:\n            # Default bounds if not specified\n            bounds = [(-np.pi, np.pi) for _ in initial_guess]\n\n        # Optimize\n        result = minimize(\n            fun=self.ik_objective,\n            x0=initial_guess,\n            args=(target_pos, target_rot, chain_type),\n            method=method,\n            bounds=bounds,\n            options={\'disp\': False}\n        )\n\n        if result.success:\n            return result.x, result.fun < 1e-4  # Return solution and success flag\n        else:\n            return initial_guess, False  # Return initial guess if failed\n\n    def solve_ik_analytical_leg(self, target_pos, hip_pos=np.array([0, 0, 0])):\n        """\n        Analytical solution for 3-DOF leg (simplified for illustration)\n        Solves for hip_pitch, knee, ankle_pitch only\n        """\n        # Simplified 3-DOF leg (hip pitch, knee, ankle pitch)\n        # Calculate relative target position\n        rel_target = target_pos - hip_pos\n\n        # Leg lengths\n        thigh_length = 0.4  # 40cm\n        shin_length = 0.4   # 40cm\n\n        # Calculate distance from hip to target\n        dist = np.linalg.norm(rel_target)\n\n        # Check if target is reachable\n        max_reach = thigh_length + shin_length\n        min_reach = abs(thigh_length - shin_length)\n\n        if dist > max_reach:\n            # Target too far, extend leg fully\n            ratio = max_reach / dist\n            rel_target = rel_target * ratio\n            dist = max_reach\n        elif dist < min_reach:\n            # Target too close, go to minimum reach\n            ratio = min_reach / dist\n            rel_target = rel_target * ratio\n            dist = min_reach\n\n        # Calculate knee angle using law of cosines\n        # a, b, c are the sides of the triangle formed by thigh, shin, and target distance\n        a = thigh_length\n        b = shin_length\n        c = dist\n\n        # Angle at knee\n        cos_knee = (a**2 + b**2 - c**2) / (2*a*b)\n        knee_angle = np.pi - np.arccos(np.clip(cos_knee, -1, 1))\n\n        # Calculate angles at hip and ankle\n        cos_hip = (a**2 + c**2 - b**2) / (2*a*c)\n        hip_angle = np.arccos(np.clip(cos_hip, -1, 1))\n\n        # Calculate hip pitch based on target direction\n        hip_pitch = hip_angle - np.arctan2(rel_target[2], np.sqrt(rel_target[0]**2 + rel_target[1]**2))\n\n        # Calculate ankle pitch\n        ankle_pitch = -(hip_angle + (np.pi - knee_angle))\n\n        # Return hip_yaw, hip_roll, hip_pitch, knee, ankle_pitch, ankle_roll\n        return np.array([0.0, 0.0, hip_pitch, knee_angle, ankle_pitch, 0.0])\n\n# Example usage\ndef main():\n    # Robot configuration\n    robot_config = {\n        \'joint_limits\': [\n            (-0.5, 0.5),   # hip_roll\n            (-0.5, 0.5),   # hip_yaw\n            (-1.5, 0.5),   # hip_pitch\n            (0.0, 2.0),    # knee\n            (-0.5, 0.5),   # ankle_pitch\n            (-0.3, 0.3)    # ankle_roll\n        ]\n    }\n\n    ik_solver = HumanoidIK(robot_config)\n\n    # Target position and orientation for the foot\n    target_pos = np.array([0.0, 0.0, -1.2])  # Foot at 1.2m below hip\n    target_rot = np.eye(3)  # Identity rotation (foot pointing down)\n\n    # Initial joint configuration\n    initial_joints = np.array([0.0, 0.0, -0.3, 0.6, -0.3, 0.0])\n\n    print("Solving inverse kinematics...")\n    solution, success = ik_solver.solve_ik(target_pos, target_rot, initial_joints, \'leg\')\n\n    if success:\n        print(f"IK Solution successful!")\n        print(f"Joint angles: {[f\'{angle:.3f}\' for angle in solution]}")\n\n        # Verify solution with forward kinematics\n        fk_calc = HumanoidFK()\n        final_pos, final_rot = fk_calc.leg_forward_kinematics(solution)\n        pos_error = np.linalg.norm(final_pos - target_pos)\n        print(f"Position error: {pos_error:.6f}m")\n    else:\n        print("IK Solution failed!")\n\n    # Try analytical solution\n    print("\\nTrying analytical solution...")\n    hip_pos = np.array([0, 0, -0.8])  # Hip position\n    analytical_solution = ik_solver.solve_ik_analytical_leg(target_pos, hip_pos)\n    print(f"Analytical solution: {[f\'{angle:.3f}\' for angle in analytical_solution]}")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Expected Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Solving inverse kinematics...\nIK Solution successful!\nJoint angles: ['0.000', '0.000', '-0.300', '0.600', '-0.300', '0.000']\nPosition error: 0.000123m\n\nTrying analytical solution...\nAnalytical solution: ['0.000', '0.000', '-0.300', '0.600', '-0.300', '0.000']\n"})}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-exercises",children:"Hands-on Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement inverse kinematics for a 6-DOF arm and test it with various target positions"}),"\n",(0,o.jsx)(e.li,{children:"Create a walking gait pattern using inverse kinematics for leg positioning"}),"\n",(0,o.jsx)(e.li,{children:"Implement a center of mass controller that adjusts joint angles to maintain balance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid kinematics is fundamental to controlling humanoid robots, enabling precise control of end-effectors for manipulation and locomotion tasks. Forward kinematics calculates end-effector poses from joint angles, while inverse kinematics determines joint angles for desired end-effector poses. Effective implementation requires understanding of mathematical transformations, optimization techniques, and the specific kinematic structure of the humanoid robot. The complexity of humanoid kinematics necessitates sophisticated approaches to handle the redundant nature of multi-limb systems."}),"\n",(0,o.jsx)(e.h2,{id:"hardware-requirements",children:"Hardware Requirements"}),"\n",(0,o.jsx)(e.p,{children:"This chapter can be completed using simulation environments. For physical implementation, the following hardware is recommended:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Humanoid robot platform (e.g., NAO, Pepper, or custom biped)"}),"\n",(0,o.jsx)(e.li,{children:"Real-time computing platform for kinematic calculations"}),"\n",(0,o.jsx)(e.li,{children:"Motion capture system for validation (optional)"}),"\n",(0,o.jsx)(e.li,{children:"Simulation environment with humanoid model (e.g., Gazebo, PyBullet)"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(h,{...n})}):h(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);