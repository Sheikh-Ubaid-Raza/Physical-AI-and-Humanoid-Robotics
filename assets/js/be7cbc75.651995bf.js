"use strict";(globalThis.webpackChunkwebsite_name=globalThis.webpackChunkwebsite_name||[]).push([[8903],{8445:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"week-06/gazebo-environment-setup","title":"Gazebo Environment Setup: URDF/SDF Formats, Physics Simulation","description":"Learning Objectives","source":"@site/docs/week-06/gazebo-environment-setup.md","sourceDirName":"week-06","slug":"/week-06/gazebo-environment-setup","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-06/gazebo-environment-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/Sheikh-Ubaid-Raza/Physical-AI-and-Humanoid-Robotics/edit/main/docs/week-06/gazebo-environment-setup.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Gazebo Environment Setup: URDF/SDF Formats, Physics Simulation"},"sidebar":"tutorialSidebar","previous":{"title":"Launch Files, Parameter Management, URDF Basics","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-05/launch-files-urdf-basics"},"next":{"title":"Unity for Robot Visualization","permalink":"/Physical-AI-and-Humanoid-Robotics/docs/week-07/unity-robot-visualization"}}');var t=i(4848),r=i(8453);const s={sidebar_position:1,title:"Gazebo Environment Setup: URDF/SDF Formats, Physics Simulation"},a="Gazebo Environment Setup: URDF/SDF Formats, Physics Simulation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Theory",id:"theory",level:2},{value:"URDF vs SDF",id:"urdf-vs-sdf",level:3},{value:"Physics Simulation",id:"physics-simulation",level:3},{value:"Gazebo Plugins",id:"gazebo-plugins",level:3},{value:"Code Example 1: SDF Conversion and World Definition",id:"code-example-1-sdf-conversion-and-world-definition",level:2},{value:"Code Example 2: Robot Simulation Launch File",id:"code-example-2-robot-simulation-launch-file",level:2},{value:"Hands-on Exercises",id:"hands-on-exercises",level:2},{value:"Summary",id:"summary",level:2},{value:"Hardware Requirements",id:"hardware-requirements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"gazebo-environment-setup-urdfsdf-formats-physics-simulation",children:"Gazebo Environment Setup: URDF/SDF Formats, Physics Simulation"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set up Gazebo simulation environments for robot testing"}),"\n",(0,t.jsx)(n.li,{children:"Convert URDF models to SDF format for Gazebo"}),"\n",(0,t.jsx)(n.li,{children:"Configure physics parameters for realistic simulation"}),"\n",(0,t.jsx)(n.li,{children:"Implement robot controllers that work in simulation"}),"\n",(0,t.jsx)(n.li,{children:"Design simulation scenarios that match real-world conditions"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understanding of URDF robot description format (covered in Week 5)"}),"\n",(0,t.jsx)(n.li,{children:"Basic knowledge of robot physics and dynamics"}),"\n",(0,t.jsx)(n.li,{children:"Experience with ROS 2 launch files (covered in Week 5)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo is a physics-based simulator that enables testing of robot software in realistic environments. It provides high-fidelity physics simulation, high-quality graphics rendering, and sensor simulation that closely matches real-world behavior."}),"\n",(0,t.jsx)(n.h3,{id:"urdf-vs-sdf",children:"URDF vs SDF"}),"\n",(0,t.jsx)(n.p,{children:"While URDF (Unified Robot Description Format) is the standard for robot description in ROS, Gazebo uses SDF (Simulation Description Format). Although URDF can be loaded directly into Gazebo, SDF offers more features specifically for simulation including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Physics parameters (friction, damping, restitution)"}),"\n",(0,t.jsx)(n.li,{children:"Sensor definitions with noise models"}),"\n",(0,t.jsx)(n.li,{children:"Plugin specifications for Gazebo-specific functionality"}),"\n",(0,t.jsx)(n.li,{children:"Environment and world descriptions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"physics-simulation",children:"Physics Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo uses the ODE (Open Dynamics Engine) physics engine by default, though it can be configured to use other engines like Bullet or DART. Physics parameters that affect simulation realism include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Gravity: Standard value is 9.81 m/s\xb2 downward"}),"\n",(0,t.jsx)(n.li,{children:"Friction: Determines how surfaces interact (mu1, mu2 parameters)"}),"\n",(0,t.jsx)(n.li,{children:"Damping: Reduces motion over time (angular and linear damping)"}),"\n",(0,t.jsx)(n.li,{children:"Restitution: Determines bounciness of collisions (coefficient of restitution)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"gazebo-plugins",children:"Gazebo Plugins"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo plugins are shared libraries that provide additional functionality to models and sensors in the simulation. Common plugins include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joint state publishers"}),"\n",(0,t.jsx)(n.li,{children:"Robot state publishers"}),"\n",(0,t.jsx)(n.li,{children:"Controller interfaces (for ROS 2 integration)"}),"\n",(0,t.jsx)(n.li,{children:"Sensor drivers (camera, LIDAR, IMU, etc.)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-example-1-sdf-conversion-and-world-definition",children:"Code Example 1: SDF Conversion and World Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- worlds/my_robot_world.sdf --\x3e\n\x3c!-- Purpose: Define a simulation world with robot and environment --\x3e\n\x3c!-- Setup Instructions: Place in worlds directory of Gazebo package --\x3e\n\x3c!-- Run: gazebo worlds/my_robot_world.sdf --\x3e\n\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="my_robot_world">\n\n    \x3c!-- Physics Engine Configuration --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.81</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.0</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.6 0.3 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n            <specular>0.7 0.7 0.7 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Include Robot Model --\x3e\n    <include>\n      <uri>model://my_robot</uri>\n      <pose>0 0 0.1 0 0 0</pose>\n    </include>\n\n    \x3c!-- Obstacle --\x3e\n    <model name="box_obstacle">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="box_link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.5</mu>\n                <mu2>0.5</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n            <specular>0.8 0.2 0.2 1</specular>\n          </material>\n        </visual>\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.083</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.083</iyy>\n            <iyz>0</iyz>\n            <izz>0.042</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# When running Gazebo with this world file:\nGazebo multi-robot simulator, version 11.0.0\nCopyright (C) 2012 Open Source Robotics Foundation.\nReleased under the Apache 2.0 License.\n[Msg] Waiting for master.\n[Msg] Connected to gazebo master @ http://127.0.0.1:11345\n[Msg] Loading world file [/path/to/worlds/my_robot_world.sdf]\n[Msg] Successfully launched Gazebo with world: my_robot_world.sdf\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code-example-2-robot-simulation-launch-file",children:"Code Example 2: Robot Simulation Launch File"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# launch/robot_gazebo.launch.py\n# Purpose: Launch robot in Gazebo with controllers\n# Setup Instructions: Place in launch directory of ROS 2 package\n# Run: ros2 launch my_robot_package robot_gazebo.launch.py\n\nimport os\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, ExecuteProcess, RegisterEventHandler\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.event_handlers import OnProcessExit\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    # Get package directories\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n    pkg_my_robot = get_package_share_directory('my_robot_package')\n\n    # World file\n    world_file = os.path.join(\n        get_package_share_directory('my_robot_package'),\n        'worlds',\n        'my_robot_world.sdf'\n    )\n\n    # Launch Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(pkg_gazebo_ros, 'launch', 'gazebo.launch.py')\n        ),\n        launch_arguments={'world': world_file}.items()\n    )\n\n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'my_robot',\n            '-x', '0', '-y', '0', '-z', '0.1'\n        ],\n        output='screen'\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='screen',\n        parameters=[{'use_sim_time': True}]\n    )\n\n    # Joint state broadcaster\n    joint_state_broadcaster_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"joint_state_broadcaster\"],\n    )\n\n    # Diff drive controller\n    diff_drive_spawner = Node(\n        package=\"controller_manager\",\n        executable=\"spawner\",\n        arguments=[\"diff_drive_controller\"],\n    )\n\n    return LaunchDescription([\n        gazebo,\n        spawn_entity,\n        robot_state_publisher,\n        joint_state_broadcaster_spawner,\n        diff_drive_spawner,\n    ])\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Expected Output:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[INFO] [launch]: All processes have started successfully\n[gazebo-1] Gazebo is launched with the custom world\n[INFO] [spawn_entity.py]: Spawned entity [my_robot]\n[robot_state_publisher-2] Publishing robot state\n[INFO] [controller_manager]: Loaded joint_state_broadcaster\n[INFO] [controller_manager]: Loaded diff_drive_controller\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hands-on-exercises",children:"Hands-on Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a Gazebo world with multiple obstacles and simulate robot navigation through the environment"}),"\n",(0,t.jsx)(n.li,{children:"Configure physics parameters to simulate different ground conditions (ice, sand, grass) and observe the effect on robot mobility"}),"\n",(0,t.jsx)(n.li,{children:"Implement a sensor-equipped robot model in Gazebo and verify that sensor data matches expected real-world behavior"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo provides a powerful simulation environment for testing robot software before deployment to physical hardware. Proper configuration of physics parameters, world environments, and robot models is crucial for achieving realistic simulation that translates well to real-world performance. The integration of Gazebo with ROS 2 enables seamless development and testing of robot applications."}),"\n",(0,t.jsx)(n.h2,{id:"hardware-requirements",children:"Hardware Requirements"}),"\n",(0,t.jsx)(n.p,{children:"This chapter can be completed using simulation environments. For physical implementation, the following hardware is recommended:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Computer with Gazebo Garden or Fortress installed"}),"\n",(0,t.jsx)(n.li,{children:"Adequate GPU for rendering (OpenGL 2.1+)"}),"\n",(0,t.jsx)(n.li,{children:"Robot hardware compatible with URDF/SDF models for validation"}),"\n",(0,t.jsx)(n.li,{children:"Simulation-to-reality comparison setup (optional for basic exercises)"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var o=i(6540);const t={},r=o.createContext(t);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);